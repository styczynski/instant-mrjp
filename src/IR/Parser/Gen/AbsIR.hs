-- File generated by the BNF Converter (bnfc 2.9.4).

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language IR.

module IR.Parser.Gen.AbsIR where

import Prelude (Integer, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

import qualified Data.Data    as C (Data, Typeable)
import qualified GHC.Generics as C (Generic)

type QIdent = QIdent' BNFC'Position
data QIdent' a = QIdent a IRTargetRefName IRTargetRefName
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Program = Program' BNFC'Position
data Program' a = Program a (Metadata' a) [Method' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Metadata = Metadata' BNFC'Position
data Metadata' a = Meta a [ClassDef' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ClassDef = ClassDef' BNFC'Position
data ClassDef' a = ClDef a IRTargetRefName [FieldDef' a] [MethodDef' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type FieldDef = FieldDef' BNFC'Position
data FieldDef' a = FldDef a (SType' a) IRTargetRefName
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MethodDef = MethodDef' BNFC'Position
data MethodDef' a = MthdDef a (FType' a) (QIdent' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type FType = FType' BNFC'Position
data FType' a = FType a (SType' a) [SType' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type SType = SType' BNFC'Position
data SType' a
    = Int a
    | Bool a
    | Void a
    | Arr a (SType' a)
    | Cl a IRTargetRefName
    | Ref a (SType' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Method = Method' BNFC'Position
data Method' a
    = Mthd a (SType' a) (QIdent' a) [Param' a] [Instr' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Param = Param' BNFC'Position
data Param' a = Param a (SType' a) IRValueName
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Instr = Instr' BNFC'Position
data Instr' a
    = ILabel a IRLabelName
    | ILabelAnn a IRLabelName Integer Integer
    | IVRet a
    | IRet a (Val' a)
    | IOp a IRValueName (Val' a) (Op' a) (Val' a)
    | ISet a IRValueName (Val' a)
    | ISwap a (SType' a) IRValueName IRValueName
    | IUnOp a IRValueName (UnOp' a) (Val' a)
    | IVCall a (Call' a)
    | ICall a IRValueName (Call' a)
    | INew a IRValueName (SType' a)
    | INewArr a IRValueName (SType' a) (Val' a)
    | INewStr a IRValueName String
    | IJmp a IRLabelName
    | ICondJmp a (Val' a) IRLabelName IRLabelName
    | ILoad a IRValueName (Ptr' a)
    | IStore a (Val' a) (Ptr' a)
    | IPhi a IRValueName [PhiVariant' a]
    | IEndPhi a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Ptr = Ptr' BNFC'Position
data Ptr' a
    = PFld a (SType' a) (Val' a) (QIdent' a)
    | PElem a (SType' a) (Val' a) (Val' a)
    | PArrLen a (Val' a)
    | PLocal a (SType' a) Integer
    | PParam a (SType' a) Integer IRValueName
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type PhiVariant = PhiVariant' BNFC'Position
data PhiVariant' a = PhiVar a IRLabelName (Val' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Call = Call' BNFC'Position
data Call' a
    = Call a (SType' a) (QIdent' a) [Val' a]
    | CallVirt a (SType' a) (QIdent' a) [Val' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Val = Val' BNFC'Position
data Val' a
    = VInt a Integer
    | VNegInt a Integer
    | VTrue a
    | VFalse a
    | VNull a (SType' a)
    | VVal a (SType' a) IRValueName
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Op = Op' BNFC'Position
data Op' a
    = OpAdd a
    | OpSub a
    | OpMul a
    | OpDiv a
    | OpMod a
    | OpLTH a
    | OpLE a
    | OpGTH a
    | OpGE a
    | OpEQU a
    | OpNE a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type UnOp = UnOp' BNFC'Position
data UnOp' a = UnOpNeg a | UnOpNot a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

newtype IRTargetRefName = IRTargetRefName String
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype IRLabelName = IRLabelName String
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

newtype IRValueName = IRValueName String
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition QIdent where
  hasPosition = \case
    QIdent p _ _ -> p

instance HasPosition Program where
  hasPosition = \case
    Program p _ _ -> p

instance HasPosition Metadata where
  hasPosition = \case
    Meta p _ -> p

instance HasPosition ClassDef where
  hasPosition = \case
    ClDef p _ _ _ -> p

instance HasPosition FieldDef where
  hasPosition = \case
    FldDef p _ _ -> p

instance HasPosition MethodDef where
  hasPosition = \case
    MthdDef p _ _ -> p

instance HasPosition FType where
  hasPosition = \case
    FType p _ _ -> p

instance HasPosition SType where
  hasPosition = \case
    Int p -> p
    Bool p -> p
    Void p -> p
    Arr p _ -> p
    Cl p _ -> p
    Ref p _ -> p

instance HasPosition Method where
  hasPosition = \case
    Mthd p _ _ _ _ -> p

instance HasPosition Param where
  hasPosition = \case
    Param p _ _ -> p

instance HasPosition Instr where
  hasPosition = \case
    ILabel p _ -> p
    ILabelAnn p _ _ _ -> p
    IVRet p -> p
    IRet p _ -> p
    IOp p _ _ _ _ -> p
    ISet p _ _ -> p
    ISwap p _ _ _ -> p
    IUnOp p _ _ _ -> p
    IVCall p _ -> p
    ICall p _ _ -> p
    INew p _ _ -> p
    INewArr p _ _ _ -> p
    INewStr p _ _ -> p
    IJmp p _ -> p
    ICondJmp p _ _ _ -> p
    ILoad p _ _ -> p
    IStore p _ _ -> p
    IPhi p _ _ -> p
    IEndPhi p -> p

instance HasPosition Ptr where
  hasPosition = \case
    PFld p _ _ _ -> p
    PElem p _ _ _ -> p
    PArrLen p _ -> p
    PLocal p _ _ -> p
    PParam p _ _ _ -> p

instance HasPosition PhiVariant where
  hasPosition = \case
    PhiVar p _ _ -> p

instance HasPosition Call where
  hasPosition = \case
    Call p _ _ _ -> p
    CallVirt p _ _ _ -> p

instance HasPosition Val where
  hasPosition = \case
    VInt p _ -> p
    VNegInt p _ -> p
    VTrue p -> p
    VFalse p -> p
    VNull p _ -> p
    VVal p _ _ -> p

instance HasPosition Op where
  hasPosition = \case
    OpAdd p -> p
    OpSub p -> p
    OpMul p -> p
    OpDiv p -> p
    OpMod p -> p
    OpLTH p -> p
    OpLE p -> p
    OpGTH p -> p
    OpGE p -> p
    OpEQU p -> p
    OpNE p -> p

instance HasPosition UnOp where
  hasPosition = \case
    UnOpNeg p -> p
    UnOpNot p -> p


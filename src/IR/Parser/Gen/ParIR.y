-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module IR.Parser.Gen.ParIR
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified IR.Parser.Gen.AbsIR
import IR.Parser.Gen.LexIR

}

%name pProgram_internal Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'         { PT _ (TS _ 1)       }
  '!='        { PT _ (TS _ 2)       }
  '%'         { PT _ (TS _ 3)       }
  '&'         { PT _ (TS _ 4)       }
  '('         { PT _ (TS _ 5)       }
  ')'         { PT _ (TS _ 6)       }
  '*'         { PT _ (TS _ 7)       }
  '+'         { PT _ (TS _ 8)       }
  ','         { PT _ (TS _ 9)       }
  '-'         { PT _ (TS _ 10)      }
  '.'         { PT _ (TS _ 11)      }
  '.classes'  { PT _ (TS _ 12)      }
  '.fields'   { PT _ (TS _ 13)      }
  '.metadata' { PT _ (TS _ 14)      }
  '.method'   { PT _ (TS _ 15)      }
  '.methods'  { PT _ (TS _ 16)      }
  '/'         { PT _ (TS _ 17)      }
  ':'         { PT _ (TS _ 18)      }
  ':='        { PT _ (TS _ 19)      }
  ';'         { PT _ (TS _ 20)      }
  '<'         { PT _ (TS _ 21)      }
  '<='        { PT _ (TS _ 22)      }
  '=='        { PT _ (TS _ 23)      }
  '>'         { PT _ (TS _ 24)      }
  '>='        { PT _ (TS _ 25)      }
  '['         { PT _ (TS _ 26)      }
  '[]'        { PT _ (TS _ 27)      }
  ']'         { PT _ (TS _ 28)      }
  'arrlen'    { PT _ (TS _ 29)      }
  'boolean'   { PT _ (TS _ 30)      }
  'call'      { PT _ (TS _ 31)      }
  'callvirt'  { PT _ (TS _ 32)      }
  'elemptr'   { PT _ (TS _ 33)      }
  'else'      { PT _ (TS _ 34)      }
  'endphi'    { PT _ (TS _ 35)      }
  'false'     { PT _ (TS _ 36)      }
  'fldptr'    { PT _ (TS _ 37)      }
  'if'        { PT _ (TS _ 38)      }
  'int'       { PT _ (TS _ 39)      }
  'into'      { PT _ (TS _ 40)      }
  'jump'      { PT _ (TS _ 41)      }
  'lines'     { PT _ (TS _ 42)      }
  'load'      { PT _ (TS _ 43)      }
  'local'     { PT _ (TS _ 44)      }
  'new'       { PT _ (TS _ 45)      }
  'newarr'    { PT _ (TS _ 46)      }
  'newstr'    { PT _ (TS _ 47)      }
  'null'      { PT _ (TS _ 48)      }
  'param'     { PT _ (TS _ 49)      }
  'phi'       { PT _ (TS _ 50)      }
  'return'    { PT _ (TS _ 51)      }
  'store'     { PT _ (TS _ 52)      }
  'swap'      { PT _ (TS _ 53)      }
  'then'      { PT _ (TS _ 54)      }
  'to'        { PT _ (TS _ 55)      }
  'true'      { PT _ (TS _ 56)      }
  'void'      { PT _ (TS _ 57)      }
  L_integ     { PT _ (TI _)         }
  L_quoted    { PT _ (TL _)         }
  L_SymIdent  { PT _ (T_SymIdent _) }
  L_LabIdent  { PT _ (T_LabIdent _) }
  L_ValIdent  { PT _ (T_ValIdent _) }

%%

Integer :: { (IR.Parser.Gen.AbsIR.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (IR.Parser.Gen.AbsIR.BNFC'Position, String) }
String   : L_quoted { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

SymIdent :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.SymIdent) }
SymIdent  : L_SymIdent { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.SymIdent (tokenText $1)) }

LabIdent :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.LabIdent) }
LabIdent  : L_LabIdent { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.LabIdent (tokenText $1)) }

ValIdent :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.ValIdent) }
ValIdent  : L_ValIdent { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.ValIdent (tokenText $1)) }

QIdent :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.QIdent) }
QIdent
  : SymIdent '.' SymIdent { (fst $1, IR.Parser.Gen.AbsIR.QIdent (fst $1) (snd $1) (snd $3)) }

Program :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.Program) }
Program
  : Metadata ListMethod { (fst $1, IR.Parser.Gen.AbsIR.Program (fst $1) (snd $1) (snd $2)) }

Metadata :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.Metadata) }
Metadata
  : '.metadata' ':' '[' '.classes' ':' '[' ListClassDef ']' ']' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.Meta (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $7)) }

ClassDef :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.ClassDef) }
ClassDef
  : SymIdent ':' '[' '.fields' ':' '[' ListFieldDef ']' '.methods' ':' '[' ListMethodDef ']' ']' { (fst $1, IR.Parser.Gen.AbsIR.ClDef (fst $1) (snd $1) (snd $7) (snd $12)) }

FieldDef :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.FieldDef) }
FieldDef
  : SType SymIdent { (fst $1, IR.Parser.Gen.AbsIR.FldDef (fst $1) (snd $1) (snd $2)) }

MethodDef :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.MethodDef) }
MethodDef
  : FType QIdent { (fst $1, IR.Parser.Gen.AbsIR.MthdDef (fst $1) (snd $1) (snd $2)) }

ListFieldDef :: { (IR.Parser.Gen.AbsIR.BNFC'Position, [IR.Parser.Gen.AbsIR.FieldDef]) }
ListFieldDef
  : {- empty -} { (IR.Parser.Gen.AbsIR.BNFC'NoPosition, []) }
  | FieldDef ';' ListFieldDef { (fst $1, (:) (snd $1) (snd $3)) }

ListMethodDef :: { (IR.Parser.Gen.AbsIR.BNFC'Position, [IR.Parser.Gen.AbsIR.MethodDef]) }
ListMethodDef
  : {- empty -} { (IR.Parser.Gen.AbsIR.BNFC'NoPosition, []) }
  | MethodDef ';' ListMethodDef { (fst $1, (:) (snd $1) (snd $3)) }

ListClassDef :: { (IR.Parser.Gen.AbsIR.BNFC'Position, [IR.Parser.Gen.AbsIR.ClassDef]) }
ListClassDef
  : {- empty -} { (IR.Parser.Gen.AbsIR.BNFC'NoPosition, []) }
  | ClassDef ListClassDef { (fst $1, (:) (snd $1) (snd $2)) }

FType :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.FType) }
FType
  : SType '(' ListSType ')' { (fst $1, IR.Parser.Gen.AbsIR.FType (fst $1) (snd $1) (snd $3)) }

SType :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.SType) }
SType
  : 'int' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.Int (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | 'boolean' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.Bool (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | 'void' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.Void (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | SType '[]' { (fst $1, IR.Parser.Gen.AbsIR.Arr (fst $1) (snd $1)) }
  | SymIdent { (fst $1, IR.Parser.Gen.AbsIR.Cl (fst $1) (snd $1)) }
  | SType '&' { (fst $1, IR.Parser.Gen.AbsIR.Ref (fst $1) (snd $1)) }

ListSType :: { (IR.Parser.Gen.AbsIR.BNFC'Position, [IR.Parser.Gen.AbsIR.SType]) }
ListSType
  : {- empty -} { (IR.Parser.Gen.AbsIR.BNFC'NoPosition, []) }
  | SType { (fst $1, (:[]) (snd $1)) }
  | SType ',' ListSType { (fst $1, (:) (snd $1) (snd $3)) }

Method :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.Method) }
Method
  : '.method' SType QIdent '(' ListParam ')' ':' '[' ListInstr ']' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.Mthd (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $5) (snd $9)) }

Param :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.Param) }
Param
  : SType ValIdent { (fst $1, IR.Parser.Gen.AbsIR.Param (fst $1) (snd $1) (snd $2)) }

ListParam :: { (IR.Parser.Gen.AbsIR.BNFC'Position, [IR.Parser.Gen.AbsIR.Param]) }
ListParam
  : {- empty -} { (IR.Parser.Gen.AbsIR.BNFC'NoPosition, []) }
  | Param { (fst $1, (:[]) (snd $1)) }
  | Param ',' ListParam { (fst $1, (:) (snd $1) (snd $3)) }

ListMethod :: { (IR.Parser.Gen.AbsIR.BNFC'Position, [IR.Parser.Gen.AbsIR.Method]) }
ListMethod
  : {- empty -} { (IR.Parser.Gen.AbsIR.BNFC'NoPosition, []) }
  | Method ListMethod { (fst $1, (:) (snd $1) (snd $2)) }

Instr :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.Instr) }
Instr
  : LabIdent ':' { (fst $1, IR.Parser.Gen.AbsIR.ILabel (fst $1) (snd $1)) }
  | LabIdent ':' '(' 'lines' Integer 'to' Integer ')' { (fst $1, IR.Parser.Gen.AbsIR.ILabelAnn (fst $1) (snd $1) (snd $5) (snd $7)) }
  | 'return' ';' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.IVRet (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | 'return' Val ';' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.IRet (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | ValIdent ':=' Val Op Val ';' { (fst $1, IR.Parser.Gen.AbsIR.IOp (fst $1) (snd $1) (snd $3) (snd $4) (snd $5)) }
  | ValIdent ':=' Val ';' { (fst $1, IR.Parser.Gen.AbsIR.ISet (fst $1) (snd $1) (snd $3)) }
  | 'swap' SType ValIdent ValIdent ';' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.ISwap (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $4)) }
  | ValIdent ':=' UnOp Val ';' { (fst $1, IR.Parser.Gen.AbsIR.IUnOp (fst $1) (snd $1) (snd $3) (snd $4)) }
  | Call ';' { (fst $1, IR.Parser.Gen.AbsIR.IVCall (fst $1) (snd $1)) }
  | ValIdent ':=' Call ';' { (fst $1, IR.Parser.Gen.AbsIR.ICall (fst $1) (snd $1) (snd $3)) }
  | ValIdent ':=' 'new' SType ';' { (fst $1, IR.Parser.Gen.AbsIR.INew (fst $1) (snd $1) (snd $4)) }
  | ValIdent ':=' 'newarr' SType '[' Val ']' ';' { (fst $1, IR.Parser.Gen.AbsIR.INewArr (fst $1) (snd $1) (snd $4) (snd $6)) }
  | ValIdent ':=' 'newstr' String ';' { (fst $1, IR.Parser.Gen.AbsIR.INewStr (fst $1) (snd $1) (snd $4)) }
  | 'jump' LabIdent ';' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.IJmp (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'jump' 'if' Val 'then' LabIdent 'else' LabIdent ';' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.ICondJmp (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5) (snd $7)) }
  | ValIdent ':=' 'load' Ptr ';' { (fst $1, IR.Parser.Gen.AbsIR.ILoad (fst $1) (snd $1) (snd $4)) }
  | 'store' Val 'into' Ptr ';' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.IStore (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | ValIdent ':=' 'phi' '(' ListPhiVariant ')' ';' { (fst $1, IR.Parser.Gen.AbsIR.IPhi (fst $1) (snd $1) (snd $5)) }
  | 'endphi' ';' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.IEndPhi (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }

Ptr :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.Ptr) }
Ptr
  : SType 'fldptr' Val QIdent { (fst $1, IR.Parser.Gen.AbsIR.PFld (fst $1) (snd $1) (snd $3) (snd $4)) }
  | SType 'elemptr' Val '[' Val ']' { (fst $1, IR.Parser.Gen.AbsIR.PElem (fst $1) (snd $1) (snd $3) (snd $5)) }
  | 'arrlen' Val { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.PArrLen (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | SType 'local' Integer { (fst $1, IR.Parser.Gen.AbsIR.PLocal (fst $1) (snd $1) (snd $3)) }
  | SType 'param' Integer ValIdent { (fst $1, IR.Parser.Gen.AbsIR.PParam (fst $1) (snd $1) (snd $3) (snd $4)) }

PhiVariant :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.PhiVariant) }
PhiVariant
  : LabIdent ':' Val { (fst $1, IR.Parser.Gen.AbsIR.PhiVar (fst $1) (snd $1) (snd $3)) }

Call :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.Call) }
Call
  : 'call' SType QIdent '(' ListVal ')' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.Call (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $5)) }
  | 'callvirt' SType QIdent '(' ListVal ')' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.CallVirt (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $5)) }

ListInstr :: { (IR.Parser.Gen.AbsIR.BNFC'Position, [IR.Parser.Gen.AbsIR.Instr]) }
ListInstr
  : {- empty -} { (IR.Parser.Gen.AbsIR.BNFC'NoPosition, []) }
  | Instr ListInstr { (fst $1, (:) (snd $1) (snd $2)) }

ListVal :: { (IR.Parser.Gen.AbsIR.BNFC'Position, [IR.Parser.Gen.AbsIR.Val]) }
ListVal
  : {- empty -} { (IR.Parser.Gen.AbsIR.BNFC'NoPosition, []) }
  | Val { (fst $1, (:[]) (snd $1)) }
  | Val ',' ListVal { (fst $1, (:) (snd $1) (snd $3)) }

ListPhiVariant :: { (IR.Parser.Gen.AbsIR.BNFC'Position, [IR.Parser.Gen.AbsIR.PhiVariant]) }
ListPhiVariant
  : {- empty -} { (IR.Parser.Gen.AbsIR.BNFC'NoPosition, []) }
  | PhiVariant { (fst $1, (:[]) (snd $1)) }
  | PhiVariant ',' ListPhiVariant { (fst $1, (:) (snd $1) (snd $3)) }

Val :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.Val) }
Val
  : Integer { (fst $1, IR.Parser.Gen.AbsIR.VInt (fst $1) (snd $1)) }
  | '-' Integer { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.VNegInt (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'true' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.VTrue (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | 'false' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.VFalse (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | SType 'null' { (fst $1, IR.Parser.Gen.AbsIR.VNull (fst $1) (snd $1)) }
  | SType ValIdent { (fst $1, IR.Parser.Gen.AbsIR.VVal (fst $1) (snd $1) (snd $2)) }

Op :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.Op) }
Op
  : '+' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpAdd (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '-' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpSub (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '*' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpMul (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '/' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpDiv (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '%' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpMod (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '<' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpLTH (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '<=' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpLE (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '>' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpGTH (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '>=' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpGE (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '==' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpEQU (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '!=' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.OpNE (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }

UnOp :: { (IR.Parser.Gen.AbsIR.BNFC'Position, IR.Parser.Gen.AbsIR.UnOp) }
UnOp
  : '-' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.UnOpNeg (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }
  | '!' { (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1), IR.Parser.Gen.AbsIR.UnOpNot (uncurry IR.Parser.Gen.AbsIR.BNFC'Position (tokenLineCol $1))) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err IR.Parser.Gen.AbsIR.Program
pProgram = fmap snd . pProgram_internal
}


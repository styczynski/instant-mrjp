-- File generated by the BNF Converter (bnfc 2.9.4).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module IR.Parser.Gen.SkelIR where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified IR.Parser.Gen.AbsIR

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transSymIdent :: IR.Parser.Gen.AbsIR.SymIdent -> Result
transSymIdent x = case x of
  IR.Parser.Gen.AbsIR.SymIdent string -> failure x

transLabIdent :: IR.Parser.Gen.AbsIR.LabIdent -> Result
transLabIdent x = case x of
  IR.Parser.Gen.AbsIR.LabIdent string -> failure x

transValIdent :: IR.Parser.Gen.AbsIR.ValIdent -> Result
transValIdent x = case x of
  IR.Parser.Gen.AbsIR.ValIdent string -> failure x

transQIdent :: Show a => IR.Parser.Gen.AbsIR.QIdent' a -> Result
transQIdent x = case x of
  IR.Parser.Gen.AbsIR.QIdent _ symident1 symident2 -> failure x

transProgram :: Show a => IR.Parser.Gen.AbsIR.Program' a -> Result
transProgram x = case x of
  IR.Parser.Gen.AbsIR.Program _ metadata methods -> failure x

transMetadata :: Show a => IR.Parser.Gen.AbsIR.Metadata' a -> Result
transMetadata x = case x of
  IR.Parser.Gen.AbsIR.Meta _ classdefs -> failure x

transClassDef :: Show a => IR.Parser.Gen.AbsIR.ClassDef' a -> Result
transClassDef x = case x of
  IR.Parser.Gen.AbsIR.ClDef _ symident fielddefs methoddefs -> failure x

transFieldDef :: Show a => IR.Parser.Gen.AbsIR.FieldDef' a -> Result
transFieldDef x = case x of
  IR.Parser.Gen.AbsIR.FldDef _ stype symident -> failure x

transMethodDef :: Show a => IR.Parser.Gen.AbsIR.MethodDef' a -> Result
transMethodDef x = case x of
  IR.Parser.Gen.AbsIR.MthdDef _ ftype qident -> failure x

transFType :: Show a => IR.Parser.Gen.AbsIR.FType' a -> Result
transFType x = case x of
  IR.Parser.Gen.AbsIR.FType _ stype stypes -> failure x

transSType :: Show a => IR.Parser.Gen.AbsIR.SType' a -> Result
transSType x = case x of
  IR.Parser.Gen.AbsIR.Int _ -> failure x
  IR.Parser.Gen.AbsIR.Bool _ -> failure x
  IR.Parser.Gen.AbsIR.Void _ -> failure x
  IR.Parser.Gen.AbsIR.Arr _ stype -> failure x
  IR.Parser.Gen.AbsIR.Cl _ symident -> failure x
  IR.Parser.Gen.AbsIR.Ref _ stype -> failure x

transMethod :: Show a => IR.Parser.Gen.AbsIR.Method' a -> Result
transMethod x = case x of
  IR.Parser.Gen.AbsIR.Mthd _ stype qident params instrs -> failure x

transParam :: Show a => IR.Parser.Gen.AbsIR.Param' a -> Result
transParam x = case x of
  IR.Parser.Gen.AbsIR.Param _ stype valident -> failure x

transInstr :: Show a => IR.Parser.Gen.AbsIR.Instr' a -> Result
transInstr x = case x of
  IR.Parser.Gen.AbsIR.ILabel _ labident -> failure x
  IR.Parser.Gen.AbsIR.ILabelAnn _ labident integer1 integer2 -> failure x
  IR.Parser.Gen.AbsIR.IVRet _ -> failure x
  IR.Parser.Gen.AbsIR.IRet _ val -> failure x
  IR.Parser.Gen.AbsIR.IOp _ valident val1 op val2 -> failure x
  IR.Parser.Gen.AbsIR.ISet _ valident val -> failure x
  IR.Parser.Gen.AbsIR.ISwap _ stype valident1 valident2 -> failure x
  IR.Parser.Gen.AbsIR.IUnOp _ valident unop val -> failure x
  IR.Parser.Gen.AbsIR.IVCall _ call -> failure x
  IR.Parser.Gen.AbsIR.ICall _ valident call -> failure x
  IR.Parser.Gen.AbsIR.INew _ valident stype -> failure x
  IR.Parser.Gen.AbsIR.INewArr _ valident stype val -> failure x
  IR.Parser.Gen.AbsIR.INewStr _ valident string -> failure x
  IR.Parser.Gen.AbsIR.IJmp _ labident -> failure x
  IR.Parser.Gen.AbsIR.ICondJmp _ val labident1 labident2 -> failure x
  IR.Parser.Gen.AbsIR.ILoad _ valident ptr -> failure x
  IR.Parser.Gen.AbsIR.IStore _ val ptr -> failure x
  IR.Parser.Gen.AbsIR.IPhi _ valident phivariants -> failure x
  IR.Parser.Gen.AbsIR.IEndPhi _ -> failure x

transPtr :: Show a => IR.Parser.Gen.AbsIR.Ptr' a -> Result
transPtr x = case x of
  IR.Parser.Gen.AbsIR.PFld _ stype val qident -> failure x
  IR.Parser.Gen.AbsIR.PElem _ stype val1 val2 -> failure x
  IR.Parser.Gen.AbsIR.PArrLen _ val -> failure x
  IR.Parser.Gen.AbsIR.PLocal _ stype integer -> failure x
  IR.Parser.Gen.AbsIR.PParam _ stype integer valident -> failure x

transPhiVariant :: Show a => IR.Parser.Gen.AbsIR.PhiVariant' a -> Result
transPhiVariant x = case x of
  IR.Parser.Gen.AbsIR.PhiVar _ labident val -> failure x

transCall :: Show a => IR.Parser.Gen.AbsIR.Call' a -> Result
transCall x = case x of
  IR.Parser.Gen.AbsIR.Call _ stype qident vals -> failure x
  IR.Parser.Gen.AbsIR.CallVirt _ stype qident vals -> failure x

transVal :: Show a => IR.Parser.Gen.AbsIR.Val' a -> Result
transVal x = case x of
  IR.Parser.Gen.AbsIR.VInt _ integer -> failure x
  IR.Parser.Gen.AbsIR.VNegInt _ integer -> failure x
  IR.Parser.Gen.AbsIR.VTrue _ -> failure x
  IR.Parser.Gen.AbsIR.VFalse _ -> failure x
  IR.Parser.Gen.AbsIR.VNull _ stype -> failure x
  IR.Parser.Gen.AbsIR.VVal _ stype valident -> failure x

transOp :: Show a => IR.Parser.Gen.AbsIR.Op' a -> Result
transOp x = case x of
  IR.Parser.Gen.AbsIR.OpAdd _ -> failure x
  IR.Parser.Gen.AbsIR.OpSub _ -> failure x
  IR.Parser.Gen.AbsIR.OpMul _ -> failure x
  IR.Parser.Gen.AbsIR.OpDiv _ -> failure x
  IR.Parser.Gen.AbsIR.OpMod _ -> failure x
  IR.Parser.Gen.AbsIR.OpLTH _ -> failure x
  IR.Parser.Gen.AbsIR.OpLE _ -> failure x
  IR.Parser.Gen.AbsIR.OpGTH _ -> failure x
  IR.Parser.Gen.AbsIR.OpGE _ -> failure x
  IR.Parser.Gen.AbsIR.OpEQU _ -> failure x
  IR.Parser.Gen.AbsIR.OpNE _ -> failure x

transUnOp :: Show a => IR.Parser.Gen.AbsIR.UnOp' a -> Result
transUnOp x = case x of
  IR.Parser.Gen.AbsIR.UnOpNeg _ -> failure x
  IR.Parser.Gen.AbsIR.UnOpNot _ -> failure x

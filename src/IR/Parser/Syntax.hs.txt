{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE InstanceSigs #-}
module IR.Parser.Syntax where



import           Data.Hashable
import           Data.Int
import           Data.Maybe    (fromJust)

import IR.Parser.Gen.AbsIR hiding (QIdent, Val, Instr, Program, Metadata, FieldDef, ClassDef , MethodDef , SType, FType, Method, Param , PhiVariant, UnOp, Op)

type QIdent a = QIdent' a
type Val a = Val' a
type Instr a = Instr' a
type Program a = Program' a
type Metadata a = Metadata' a
type FieldDef a = FieldDef' a
type ClassDef a = ClassDef' a
type MethodDef a = MethodDef' a
type SType a = SType' a 
type FType a = FType' a 
type Method a = Method' a
type Param a = Param' a
type PhiVariant a = PhiVariant' a
type UnOp a = UnOp' a
type Op a = Op' a

isLabel :: Instr a -> Bool
isLabel instr = case instr of
  ILabel {}    -> True
  ILabelAnn {} -> True
  _            -> False

isPhi :: Instr a -> Bool
isPhi instr = case instr of
    IPhi {} -> True
    _       -> False

isEndPhi :: Instr a -> Bool
isEndPhi instr = case instr of
    IEndPhi {} -> True
    _          -> False

instance Eq a => Hashable (Val a) where
    hashWithSalt salt val = case val of
        VInt _ n               -> hashWithSalt salt (0 :: Int8, n)
        VNegInt _ n            -> hashWithSalt salt (0 :: Int8, -n)
        VTrue _                -> hashWithSalt salt (1 :: Int8, True)
        VFalse _               -> hashWithSalt salt (1 :: Int8, False)
        VNull _ _              -> hashWithSalt salt (2 :: Int8, False)
        VVal _ _ (ValIdent vi) -> hashWithSalt salt (3 :: Int8, vi)

instance Eq a => Hashable (SType a) where
  hashWithSalt salt val = case val of
      Int _   -> hashWithSalt salt (0 :: Int8, 0 :: Int)
      Bool _  -> hashWithSalt salt (1 :: Int8, 1 :: Int)
      Void _  -> hashWithSalt salt (2 :: Int8, 2 :: Int)
      Arr _ t -> hashWithSalt salt (3 :: Int8, hashWithSalt salt t)
      Cl _ i  -> hashWithSalt salt (4 :: Int8, hashWithSalt salt i)
      Ref _ t -> hashWithSalt salt (5 :: Int8, hashWithSalt salt t)

instance Eq a => Hashable (Op a) where
    hashWithSalt salt val = case val of
        OpAdd _ -> hashWithSalt salt (0 :: Int8)
        OpSub _ -> hashWithSalt salt (1 :: Int8)
        OpMul _ -> hashWithSalt salt (2 :: Int8)
        OpDiv _ -> hashWithSalt salt (3 :: Int8)
        OpMod _ -> hashWithSalt salt (4 :: Int8)
        OpLTH _ -> hashWithSalt salt (5 :: Int8)
        OpLE _  -> hashWithSalt salt (6 :: Int8)
        OpGTH _ -> hashWithSalt salt (7 :: Int8)
        OpGE _  -> hashWithSalt salt (8 :: Int8)
        OpEQU _ -> hashWithSalt salt (9 :: Int8)
        OpNE _  -> hashWithSalt salt (10 :: Int8)

instance Eq a => Hashable (UnOp a) where
  hashWithSalt salt val = case val of
    UnOpNeg _ -> hashWithSalt salt False
    UnOpNot _ -> hashWithSalt salt True

instance Hashable SymIdent where
  hashWithSalt :: Int -> SymIdent -> Int
  hashWithSalt salt (SymIdent s) = hashWithSalt salt s

instance Hashable ValIdent where
  hashWithSalt salt (ValIdent s) = hashWithSalt salt s

--- UTILS ---


class ToString a where
    toStr :: a -> String

instance ToString LabIdent where
    toStr (LabIdent s) = s

instance ToString SymIdent where
    toStr (SymIdent s) = s

instance ToString ValIdent where
    toStr (ValIdent s) = s

argValIdent :: String -> ValIdent
argValIdent s = ValIdent $ "%a_" ++ s


constIdent :: String -> String
constIdent = ("__const_" ++)


entryLabel :: LabIdent
entryLabel = LabIdent ".L_entry"

exitLabel :: LabIdent
exitLabel = LabIdent ".L_exit"


indexedValIdent :: String -> Integer -> ValIdent
indexedValIdent i idx =
    let suf = if idx == 0 then "" else '_':show idx
    in valIdent (i ++ suf)

labIdent :: String -> LabIdent
labIdent = LabIdent . (".L_" ++)

labelFor :: QIdent a -> LabIdent -> LabIdent
labelFor (QIdent _ (SymIdent i1) (SymIdent i2)) (LabIdent l1) = LabIdent $ i1 ++ "." ++ i2 ++ l1

phiUnfoldJumpFromToLabel :: LabIdent -> LabIdent -> LabIdent
phiUnfoldJumpFromToLabel (LabIdent from) (LabIdent to) = LabIdent $ to ++ "__from_" ++ trim from
    where
        trim ('.':'L':'_':xs) = xs
        trim xs               = xs


sanitiseAssembly :: String -> String
sanitiseAssembly s = case s of
    []     -> []
    '~':xs -> '_':'_':sanitiseAssembly xs
    x:xs   -> x:sanitiseAssembly xs


nullrefLabel :: LabIdent
nullrefLabel = LabIdent "__nullref"


valIdent :: String -> ValIdent
valIdent = ValIdent . ("%v_" ++)

vTableLabIdent :: SymIdent -> LabIdent
vTableLabIdent (SymIdent i) =  LabIdent $ "__vtable_" ++ i

runtimeSymbols :: [String]
runtimeSymbols = [
        "lat_print_int",
        "lat_print_string",
        "lat_read_int",
        "lat_read_string",
        "lat_error",
        "lat_nullref",
        "lat_new_string",
        "lat_cat_strings"
    ]


--- END UTILS ---
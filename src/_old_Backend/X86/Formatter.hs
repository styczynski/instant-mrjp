module Backend.X86.Formatter where

import Data.List

import Control.Monad

import Backend.X86.Compiler
import Reporting.Errors.Position
import qualified Backend.X86.Syntax as ASM
import qualified Linearized.Syntax as IR


paddingTo :: String -> Int -> String
paddingTo line width = line ++ (concat $ replicate (width - (length line)) " ")

renderPositionInfo :: IR.IRPosition -> String
renderPositionInfo (IR.IRPosition _ (Undefined, _)) = ""
renderPositionInfo (IR.IRPosition _ (Position id file line col, _)) =  show file ++ ": " ++ show line ++ "," ++ show col
renderPositionInfo (IR.IRPosition _ _) = ""

format :: [String] -> String -> [ASM.Instruction ASM.Position] -> ASMCompiler String
format includes fileName instrs = do
    (codeLines, _) <- foldM appendLine ([], IR.noPosIR) instrs
    let includesLines = map (\includePath -> "%include '" ++ includePath ++ "'") includes
    let prefixLines = ["Generated by Latte compiler latc_x86", "Source file: " ++ fileName]
    let codeWidth = maximum $ map (\(code, _) -> length code) codeLines
    let formattedCodeLines = map (\(code, comment) -> let c' = paddingTo code codeWidth in if null comment then code else c' ++ " ; " ++ comment) codeLines
    let allLines = (map (\l -> ";  " ++ l) prefixLines) ++ includesLines ++ formattedCodeLines
    return $ intercalate "\n" allLines
    where
        appendLine :: ([(String, String)], ASM.Position) -> (ASM.Instruction ASM.Position) -> ASMCompiler ([(String, String)], ASM.Position)
        appendLine (acc, lastPos) instr = do
            let currentPos = ASM.getPosIR instr
            let comment = if lastPos == currentPos then "" else renderPositionInfo currentPos
            let shownInstr = show $ ASM.setPosIR IR.noPosIR instr
            return $ (acc ++ [(shownInstr, comment)], currentPos)